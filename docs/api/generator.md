# Generator Module

The generator module creates requirements.txt files from discovered packages.

## Classes

### RequirementsGenerator

Generates requirements.txt content with configurable version strategies.

#### Constructor

```python
class RequirementsGenerator:
    def __init__(self, version_strategy: VersionStrategy = VersionStrategy.COMPATIBLE):
        """Initialize generator with version strategy.

        Args:
            version_strategy: How to pin package versions.
        """
```

#### Methods

##### generate()

```python
def generate(
    self,
    packages: Set[str],
    output_file: Optional[Union[str, Path]] = None,
    include_header: bool = True,
    sort_packages: bool = True
) -> str:
    """Generate requirements.txt content.

    Args:
        packages: Set of package names.
        output_file: Optional file path to write to.
        include_header: Include timestamp header.
        sort_packages: Sort packages alphabetically.

    Returns:
        Generated requirements.txt content as string.
    """
```

##### get_package_version()

```python
def get_package_version(self, package_name: str) -> Optional[str]:
    """Get installed version of a package.

    Args:
        package_name: Name of the package.

    Returns:
        Version string or None if not installed.
    """
```

##### format_requirement()

```python
def format_requirement(self, package: str, version: Optional[str]) -> str:
    """Format a single requirement line.

    Args:
        package: Package name.
        version: Version string or None.

    Returns:
        Formatted requirement line.
    """
```

### VersionStrategy

Enum defining version pinning strategies.

```python
class VersionStrategy(str, Enum):
    """Version pinning strategies for requirements."""

    EXACT = "exact"          # package==1.2.3
    COMPATIBLE = "compatible" # package~=1.2.3
    MINIMUM = "minimum"      # package>=1.2.3
    NONE = "none"            # package
```

## Version Strategies

### Exact Versions (==)

Pins to exact version installed:

```python
generator = RequirementsGenerator(VersionStrategy.EXACT)
# Output:
# requests==2.28.1
# numpy==1.24.1
# pandas==1.5.2
```

**Use for:**
- Production deployments
- Reproducible builds
- CI/CD pipelines

### Compatible Versions (~=)

Allows patch updates, prevents breaking changes:

```python
generator = RequirementsGenerator(VersionStrategy.COMPATIBLE)
# Output:
# requests~=2.28.1
# numpy~=1.24.1
# pandas~=1.5.2
```

**Use for:**
- Most projects (default)
- Development environments
- Applications

### Minimum Versions (>=)

Allows all updates above current version:

```python
generator = RequirementsGenerator(VersionStrategy.MINIMUM)
# Output:
# requests>=2.28.1
# numpy>=1.24.1
# pandas>=1.5.2
```

**Use for:**
- Python libraries
- Maximum flexibility
- Early development

### No Versions

Just package names, no version constraints:

```python
generator = RequirementsGenerator(VersionStrategy.NONE)
# Output:
# requests
# numpy
# pandas
```

**Use for:**
- Initial prototyping
- Docker builds with separate pinning
- When versions are managed elsewhere

## Usage Examples

### Basic Generation

```python
from reqtracker.generator import RequirementsGenerator, VersionStrategy

# Create generator with exact versions
generator = RequirementsGenerator(VersionStrategy.EXACT)

# Generate from packages
packages = {"requests", "flask", "numpy"}
content = generator.generate(packages)
print(content)
```

### Write to File

```python
# Generate and write to file
generator = RequirementsGenerator(VersionStrategy.COMPATIBLE)
generator.generate(
    packages={"django", "celery", "redis"},
    output_file="requirements.txt",
    include_header=True,
    sort_packages=True
)
```

### Custom Header

```python
# Generate without header
content = generator.generate(
    packages=packages,
    include_header=False
)

# Add custom header
custom_header = "# Production dependencies\n# Generated for Python 3.9\n\n"
final_content = custom_header + content
```

### Unsorted Output

```python
# Keep original order (useful for priority)
content = generator.generate(
    packages=packages,
    sort_packages=False
)
```

## Output Format

### With Header (Default)

```
# Generated by reqtracker 0.1.0
# Date: 2024-01-15 10:30:00

requests~=2.28.1
flask~=2.0.3
numpy~=1.24.1
```

### Without Header

```
requests~=2.28.1
flask~=2.0.3
numpy~=1.24.1
```

### Environment Markers

The generator preserves environment markers:

```python
# Input package with marker
packages = {"pywin32 ; platform_system=='Windows'"}

# Output preserves marker
pywin32==305 ; platform_system=='Windows'
```

## Version Detection

### How It Works

1. Uses `importlib.metadata` (Python 3.8+)
2. Falls back to `pkg_resources` if needed
3. Handles missing packages gracefully

### Version Lookup

```python
generator = RequirementsGenerator()

# Get specific package version
version = generator.get_package_version("requests")
print(f"requests version: {version}")

# Handle missing packages
version = generator.get_package_version("nonexistent")
print(f"Version: {version}")  # None
```

### Custom Version Resolution

```python
class CustomGenerator(RequirementsGenerator):
    def get_package_version(self, package_name):
        # Custom version lookup logic
        if package_name in self.version_overrides:
            return self.version_overrides[package_name]
        return super().get_package_version(package_name)
```

## Error Handling

### Missing Packages

```python
generator = RequirementsGenerator(VersionStrategy.EXACT)

# Package not installed
packages = {"requests", "nonexistent-package"}
content = generator.generate(packages)

# Output includes comment for missing packages:
# requests==2.28.1
# nonexistent-package  # Version not found
```

### File Write Errors

```python
try:
    generator.generate(
        packages=packages,
        output_file="/read-only/requirements.txt"
    )
except PermissionError:
    print("Cannot write to file")
```

## Integration Examples

### With Tracker

```python
from reqtracker.tracker import Tracker
from reqtracker.generator import RequirementsGenerator, VersionStrategy

# Track dependencies
tracker = Tracker()
packages = tracker.track(["./src"])

# Generate requirements
generator = RequirementsGenerator(VersionStrategy.COMPATIBLE)
generator.generate(packages, output_file="requirements.txt")
```

### Multiple Requirements Files

```python
packages = {"django", "requests", "pytest", "black"}

# Production requirements (exact)
prod_gen = RequirementsGenerator(VersionStrategy.EXACT)
prod_gen.generate(
    packages - {"pytest", "black"},
    output_file="requirements-prod.txt"
)

# Development requirements (compatible)
dev_gen = RequirementsGenerator(VersionStrategy.COMPATIBLE)
dev_gen.generate(
    packages,
    output_file="requirements-dev.txt"
)
```

### Custom Formatting

```python
class CustomRequirementsGenerator(RequirementsGenerator):
    def format_requirement(self, package, version):
        # Custom format with comments
        line = super().format_requirement(package, version)

        # Add package description
        description = self.get_package_description(package)
        if description:
            line += f"  # {description}"

        return line
```

## Best Practices

### Version Strategy Selection

```python
import os

# Choose strategy based on environment
env = os.getenv("ENVIRONMENT", "development")

strategy_map = {
    "production": VersionStrategy.EXACT,
    "staging": VersionStrategy.COMPATIBLE,
    "development": VersionStrategy.COMPATIBLE,
    "ci": VersionStrategy.EXACT,
}

strategy = strategy_map.get(env, VersionStrategy.COMPATIBLE)
generator = RequirementsGenerator(strategy)
```

### Package Filtering

```python
# Filter out development packages
dev_packages = {"pytest", "black", "mypy", "flake8"}
prod_packages = all_packages - dev_packages

generator.generate(prod_packages, output_file="requirements.txt")
generator.generate(dev_packages, output_file="requirements-dev.txt")
```

### Version Validation

```python
def validate_requirements(file_path):
    """Validate that all packages in requirements.txt are installable."""
    with open(file_path) as f:
        for line in f:
            if line.strip() and not line.startswith("#"):
                # Try to parse requirement
                try:
                    pkg_resources.Requirement.parse(line)
                except Exception as e:
                    print(f"Invalid requirement: {line.strip()}")
                    print(f"Error: {e}")
```

## Performance Considerations

1. **Version lookup** - Cached after first lookup
2. **Sorting** - O(n log n) for alphabetical sort
3. **File I/O** - Single write operation
4. **Memory** - Minimal, processes line by line

### Optimization Tips

```python
# Reuse generator instance for multiple generations
generator = RequirementsGenerator(VersionStrategy.COMPATIBLE)

for project in projects:
    packages = analyze_project(project)
    generator.generate(
        packages,
        output_file=f"{project}/requirements.txt"
    )
```

## Output Customization

### Custom Header

```python
class CustomGenerator(RequirementsGenerator):
    def generate(self, packages, **kwargs):
        content = super().generate(packages, **kwargs)

        # Add custom header
        header = """
# Project: MyApp
# Python: >=3.8
# Updated: 2024-01-15

"""
        return header + content
```

### Grouped Output

```python
def generate_grouped_requirements(packages_by_category):
    """Generate requirements grouped by category."""

    generator = RequirementsGenerator(VersionStrategy.COMPATIBLE)
    content = []

    for category, packages in packages_by_category.items():
        content.append(f"\n# {category}\n")
        for package in sorted(packages):
            version = generator.get_package_version(package)
            line = generator.format_requirement(package, version)
            content.append(line)

    return "\n".join(content)
```
